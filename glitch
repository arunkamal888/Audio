import javax.sound.sampled.*;
import java.io.File;
import java.io.IOException;

public class VoiceQualityAssessment {

    private static final double SNR_THRESHOLD = 15; // SNR threshold for good quality
    private static final double ENERGY_THRESHOLD = 0.01; // Energy threshold for voice activity
    private static final int ZERO_CROSSING_THRESHOLD = 10; // Zero crossing threshold

    public static void main(String[] args) {
        String filePath = "path_to_your_audio_file.wav"; // Adjust path to your audio file
        File audioFile = new File(filePath);
        
        try {
            AudioInputStream stream = AudioSystem.getAudioInputStream(audioFile);
            AudioFormat format = stream.getFormat();
            double[] samples = extractSamples(stream, format);

            boolean[] voiceActive = detectVoice(samples, format);
            double snr = calculateSNR(samples, voiceActive);
            
            System.out.println("SNR: " + snr + " dB");
            System.out.println("Audio Quality: " + (snr > SNR_THRESHOLD ? "Good" : "Not Good"));
        } catch (UnsupportedAudioFileException | IOException e) {
            e.printStackTrace();
        }
    }

    private static double[] extractSamples(AudioInputStream stream, AudioFormat format) throws IOException {
        byte[] audioBytes = stream.readAllBytes();
        double[] samples = new double[audioBytes.length / 2];

        for (int i = 0, sampleIndex = 0; i < audioBytes.length; sampleIndex++, i += 2) {
            int sample = ((audioBytes[i + 1] & 0xFF) << 8) | (audioBytes[i] & 0xFF);
            samples[sampleIndex] = sample / 32768.0; // Normalize to range [-1,1] for 16-bit audio
        }
        return samples;
    }

    private static boolean[] detectVoice(double[] samples, AudioFormat format) {
        int sampleRate = (int) format.getFrameRate();
        int frameSize = sampleRate / 10; // 100ms frames
        boolean[] voiceActive = new boolean[samples.length];

        for (int start = 0; start + frameSize < samples.length; start += frameSize) {
            double sumEnergy = 0;
            int zeroCrossings = 0;
            for (int i = start; i < start + frameSize; i++) {
                sumEnergy += samples[i] * samples[i];
                if (i > start && ((samples[i] > 0 && samples[i - 1] < 0) || (samples[i] < 0 && samples[i - 1] > 0))) {
                    zeroCrossings++;
                }
            }
            double avgEnergy = sumEnergy / frameSize;
            if (avgEnergy > ENERGY_THRESHOLD && zeroCrossings > ZERO_CROSSING_THRESHOLD) {
                for (int i = start; i < start + frameSize; i++) {
                    voiceActive[i] = true;
                }
            }
        }
        return voiceActive;
    }

    private static double calculateSNR(double[] samples, boolean[] voiceActive) {
        double signalPower = 0, noisePower = 0;
        int signalCount = 0, noiseCount = 0;

        for (int i = 0; i < samples.length; i++) {
            if (voiceActive[i]) {
                signalPower += samples[i] * samples[i];
                signalCount++;
            } else {
                noisePower += samples[i] * samples[i];
                noiseCount++;
            }
        }

        double avgSignalPower = signalCount > 0 ? signalPower / signalCount : 0;
        double avgNoisePower = noiseCount > 0 ? noisePower / noiseCount : 0;
        return avgNoisePower != 0 ? 10 * Math.log10(avgSignalPower / avgNoisePower) : Double.POSITIVE_INFINITY;
    }
}
