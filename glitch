import javax.sound.sampled.*;
import java.io.File;
import java.io.IOException;

public class AudioQualityChecker {

    // Define threshold values for good quality audio
    private static final double SNR_THRESHOLD = 20.0; // SNR should be above 20 dB for good quality
    private static final double PEAK_AMPLITUDE_THRESHOLD = 0.9; // Peak amplitude close to 1 but not clipping
    private static final double RMS_THRESHOLD = 0.1; // RMS should be reasonably high

    public static void main(String[] args) {
        String filePath = "path_to_your_audio_file.wav"; // Specify the path to your audio file
        File audioFile = new File(filePath);

        try {
            AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(audioFile);
            AudioFormat format = audioInputStream.getFormat();
            long frames = audioInputStream.getFrameLength();
            double durationInSeconds = frames / format.getFrameRate();

            double[] samples = convertToSamples(audioInputStream, format);

            double snr = calculateSNR(samples);
            double peakAmplitude = findPeakAmplitude(samples);
            double rmsAmplitude = calculateRMS(samples);

            System.out.println("SNR: " + snr + " dB");
            System.out.println("Peak Amplitude: " + peakAmplitude);
            System.out.println("RMS Amplitude: " + rmsAmplitude);

            // Evaluate audio quality
            if (snr > SNR_THRESHOLD && peakAmplitude < PEAK_AMPLITUDE_THRESHOLD && rmsAmplitude > RMS_THRESHOLD) {
                System.out.println("Audio Quality: Good");
            } else {
                System.out.println("Audio Quality: Not Good");
            }
        } catch (UnsupportedAudioFileException | IOException e) {
            e.printStackTrace();
        }
    }

    private static double[] convertToSamples(AudioInputStream stream, AudioFormat format) throws IOException {
        byte[] audioBytes = stream.readAllBytes();
        double[] samples = new double[audioBytes.length / 2];

        boolean isBigEndian = format.isBigEndian();
        for (int i = 0, sampleIndex = 0; i < audioBytes.length; sampleIndex++, i += 2) {
            int value = isBigEndian ?
                ((audioBytes[i] & 0xFF) << 8 | (audioBytes[i + 1] & 0xFF)) :
                ((audioBytes[i + 1] & 0xFF) << 8 | (audioBytes[i] & 0xFF));
            samples[sampleIndex] = value / 32768.0; // Normalizing to range [-1,1] for 16-bit audio
        }
        return samples;
    }

    private static double calculateSNR(double[] samples) {
        double signalPower = 0, noisePower = 0, avgSignal = 0;
        for (double sample : samples) {
            avgSignal += sample;
        }
        avgSignal /= samples.length;

        for (double sample : samples) {
            signalPower += Math.pow(sample - avgSignal, 2);
            noisePower += Math.pow(avgSignal, 2);
        }
        return 10 * Math.log10(signalPower / noisePower);
    }

    private static double findPeakAmplitude(double[] samples) {
        double peak = 0;
        for (double sample : samples) {
            peak = Math.max(peak, Math.abs(sample));
        }
        return peak;
    }

    private static double calculateRMS(double[] samples) {
        double rms = 0;
        for (double sample : samples) {
            rms += sample * sample;
        }
        return Math.sqrt(rms / samples.length);
    }
}
